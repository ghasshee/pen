parser Parser: 


{ 

--import Effect
--import Syntax

import GCLL
import Type
import Term
import AST 

keywords    =   [ "contract"
                , "method"   
                , "string" 
                , "bool" 
                , "u8"    
                , "u256"
                , "i8" 
                , "i256" 
                , "return" 
                , "if" 
                , "then"
                , "else" 
                , "let"
                , "letrec" 
                , "fix" 
                , "amount" 
                ]

} 

top TopLevel 


----------- LEXER ------------
Ln      :: Char     = '\n'  

Digit   :: Int      = c:Char   &{isDigit c}     -> { digitToInt c       }
Digits  :: Integer  = v:Digits d:Digit          -> { v * 10+toInteger d } 
                    / d:Digit                   -> {        toInteger d }


Hex      :: Integer = ("0x" / "0X") v:HexDigits -> { v                  } 
HexDigit :: Int     = c:Char &{isHexDigit c}    -> { digitToInt c       }
HexDigits:: Integer = v:HexDigits d:HexDigit    -> { v * 16+toInteger d }
                    / d:HexDigit                -> {        toInteger d }

Sp       :: {()}    = Space*                    -> {()}
Space    :: {()}    = White                     -> {()}
                    / Comment                   -> {()} 
White    :: Char    = ' ' / '\t' / '\f' / Ln 
Comment  :: {()}    = Comm 
                    / LnComm 
Comm     :: {()}    = "{--" (!"--}" c:Char -> c)* "--}" -> {()} 
LnComm   :: {()}    = "--"  (!Ln    c:Char -> c)* Ln    -> {()} 


Kwd      :: String  = s:Word    &{ s `elem` keywords }  -> s 

ID       :: String  = !Kwd !Bool  s:Word        -> s 

Word     :: String  = c:Init cs:Rest* Sp        -> { c:cs }

Init     :: Char    = c:Char    &{isAlpha c}    -> c
                    / '_'

Rest     :: Char    = c:Char    &{isAlphaNum c} -> c
                    / '_'

EVENT    :: {()}    = "event"       Sp          -> {}
CONTRACT :: {()}    = "contract"    Sp          -> {} 
METHOD   :: {()}    = "method"      Sp          -> {} 
RETURN   :: {()}    = "return"      Sp          -> {}
BECOME   :: {()}    = "become"      Sp          -> {}
IF       :: {()}    = "if"          Sp          -> {} 
THEN     :: {()}    = "then"        Sp          -> {} 
ELSE     :: {()}    = "else"        Sp          -> {} 
TRUE     :: {()}    = "true"        Sp          -> {}
FALSE    :: {()}    = "false"       Sp          -> {} 
LET      :: {()}    = "let"         Sp          -> {} 
WITH     :: {()}    = "with"        Sp          -> {} 
CASE     :: {()}    = "case"        Sp          -> {} 
NEW      :: {()}    = "new"         Sp          -> {} 
CALL     :: {()}    = "call"        Sp          -> {} 
SENDER   :: {()}    = "sender"      Sp          -> {} 
MSG      :: {()}    = "message"     Sp          -> {} 
AMOUNT   :: {()}    = "amount"      Sp          -> {} 
BALANCE  :: {()}    = "balance"     Sp          -> {} 
DSTRCT   :: {()}    = "destruct"    Sp          -> {} 
THIS     :: {()}    = "this"        Sp          -> {} 
NOW      :: {()}    = "now"         Sp          -> {} 
UNIT     :: {()}    = "()"          Sp          -> {} 
LOG      :: {()}    = "log"         Sp          -> {} 
KECCAK   :: {()}    = "keccak"      Sp          -> {} 

ARROW    :: {()}    = "->" Sp                   -> {} 
DARROW   :: {()}    = "=>" Sp                   -> {} 
LPAREN   :: {()}    = "("  Sp                   -> {}
RPAREN   :: {()}    = ")"  Sp                   -> {}
LBRACE   :: {()}    = "{"  Sp                   -> {}
RBRACE   :: {()}    = "}"  Sp                   -> {}
LSQUARE  :: {()}    = "["  Sp                   -> {}
RSQUARE  :: {()}    = "]"  Sp                   -> {}
COLON    :: {()}    = ":"  Sp                   -> {} 
COLONEQ  :: {()}    = ":=" Sp                   -> {} 
COMMA    :: {()}    = ","  Sp                   -> {} 
DOT      :: {()}    = "."  Sp                   -> {} 
NOT      :: {()}    = "~"  Sp                   -> {}


Sym      :: String  = s:SymChar Sp              -> s 
SymChar  :: String  = "+" / "*" / "-" / "/" 
                    / "&" / "|" / "^" / "%" / "$" / "@" / "!" / "?"
                    / "++" / "--" / "**" / "//" 
                    / "&&" / "||" / "^^" / "%%" / "$$" / "@@" 
                    / "="  / "==" / "!=" / "/=" 
                    / "[" / "]" / "{" / "}" / "(" / ")" 
                    / "<" / ">" / "<=" / ">=" / "<<" / ">>" 
                    / ">>=" / "=<<" / ">>>" / "<<<" 
                    / ".." / "..." / "...." 



--------- PARSER ------------

TopLevel :: {[Top]} = Sp t:Top Sp ts:TopLevel !Char -> { t:ts           }  
                    / t:Top                         -> { [t]            } 

Top :: Top          = CONTRACT id:ID ps:Params
                        LBRACE ms:Mthds RBRACE      -> { CN id ps ms    }  
                    / EVENT  id:ID ty:Ty            -> { EV id ty       } 

Params :: {[Ty]}    = LPAREN  ps:PTys  RPAREN       -> { ps             } 
                    / LPAREN           RPAREN       -> { []             }  

PTys    :: {[Ty]}   = p:PTy  COMMA  ps:PTys         -> { p:ps           } 
                    / p:PTy                         -> { [p]            } 

PTy     :: {Ty}     = id:ID  COLON  ty:Ty           -> { TyVAR id ty    }  

Tys    :: {[Ty]}    = t:Ty   COMMA  ts:Tys          -> { t:ts           } 
                    / t:Ty                          -> { [t]            } 

Ty     :: { Ty }    = t:PrimTy Sp                   -> { t              }
                    / a:Ty  ARROW  b:Ty             -> { TyABS a b      } 
                    / LPAREN t:Ty COMMA s:Tys RPAREN-> { TyPROD (t:s)   } 

PrimTy :: { Ty }    = "bool":Word                   -> { TyBOOL         } 
                    /   "u8":Word                   -> { TyU8           } 
                    / "u256":Word                   -> { TyU256         } 
                    /   "i8":Word                   -> { TyI8           } 
                    / "i256":Word                   -> { TyI256         } 
                    / LPAREN t:Ty RPAREN            -> { t              } 



Mthds  :: {[Mthd]}    = m:Mthd ms:Mthds             -> { m:ms           }
                      /                             -> { []             }
Mthd   :: { Mthd }    = METHOD id:ID ps:Params ARROW ret:Ty 
                        LBRACE  bd:Body RBRACE      -> { MT id ret ps k }  

Body    :: { BODY }   = 
KTm     :: { K Tm } = k:AppKTm                      -> { k              } 

AppKTm  :: { K Tm } = k:PathKTm                     -> { k              } 
                    / NOT k:PathKTm                 -> { let (s,t) = splitK k in 
                                                         s >: TmNOT (K t)   } 
                    / k1:AppKTm k2:PathKTm          -> { 
                                                         let (s1,t1) = splitK k1 in 
                                                         let (s2,t2) = splitK k2 in 
                                                         s1++s2 >: TmAPP(K t1)(K t2) }
PathKTm :: { K Tm } = k:AKTm                        -> { k              } 
AKTm    :: { K Tm } = LPAREN k:KTm RPAREN           -> { k              } 
                    / RETURN k:KTm                  -> { k              } 
                    / n:Num                         -> { pure n         }  
                    / b:Bool                        -> { pure b         } 
                    / AMOUNT                        -> { pure TmAMOUNT  } 
                    / THIS                          -> { pure TmTHIS    } 
                    / SENDER                        -> { pure TmSENDER  } 


Num      :: Tm      = n:Digits Sp                   -> { TmU256 n       } 

Bool     :: Tm      = TRUE                          -> { TmTRUE         } 
                    / FALSE                         -> { TmFALSE        } 


{ 

parse :: String -> [Top] 
parse str = case parserTopLevel (parserParse "" str) of 
    Parsed v _ _ -> v 
    NoParse e -> error (show e) 

}
