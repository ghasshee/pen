parser Parser: 


{ 

import Effect
import Syntax

keywords    =   [ "contract"
                , "method"   
                , "string" 
                , "bool" 
                , "u8"    
                , "u256"
                , "i8" 
                , "i256" 
                , "return" 
                , "if" 
                , "then"
                , "else" 
                , "let"
                , "letrec" 
                , "fix" 
                ]

} 

top TopLevel 


----------- LEXER ------------
Ln      :: Char     = '\n'  

Digit   :: Int      = c:Char   &{isDigit c}     -> { digitToInt c       }
Digits  :: Integer  = v:Digits d:Digit          -> { v * 10+toInteger d } 
                    / d:Digit                   -> {        toInteger d }


Hex      :: Integer = ("0x" / "0X") v:HexDigits -> { v                  } 
HexDigit :: Int     = c:Char &{isHexDigit c}    -> { digitToInt c       }
HexDigits:: Integer = v:HexDigits d:HexDigit    -> { v * 16+toInteger d }
                    / d:HexDigit                -> {        toInteger d }

Sp       :: {()}    = Space*                    -> {()}
Space    :: {()}    = White                     -> {()}
                    / Comment                   -> {()} 
White    :: Char    = ' ' / '\t' / '\f' / Ln 
Comment  :: {()}    = Comm 
                    / LnComm 
Comm     :: {()}    = "{--" (!"--}" c:Char -> c)* "--}" -> {()} 
LnComm   :: {()}    = "--"  (!Ln    c:Char -> c)* Ln    -> {()} 


Kwd      :: String  = s:Word    &{ s `elem` keywords }  -> s 

ID       :: String  = !Kwd !Bool  s:Word        -> s 

Word     :: String  = c:Init cs:Rest* Sp        -> { c:cs }

Init     :: Char    = c:Char    &{isAlpha c}    -> c
                    / '_'
Rest     :: Char    = c:Char    &{isAlphaNum c} -> c
                    / '_'

EVENT    :: {()}    = "event" Sp                -> {}
CONTRACT :: {()}    = "contract" Sp             -> {} 
METHOD   :: {()}    = "method" Sp               -> {} 
ARROW    :: {()}    = "->" Sp                   -> {} 
DARROW   :: {()}    = "=>" Sp                   -> {} 
LPAREN   :: {()}    = "("  Sp                   -> {}
RPAREN   :: {()}    = ")"  Sp                   -> {}
LBRACE   :: {()}    = "{"  Sp                   -> {}
RBRACE   :: {()}    = "}"  Sp                   -> {}
LSQUARE  :: {()}    = "["  Sp                   -> {}
RSQUARE  :: {()}    = "]"  Sp                   -> {}
COLON    :: {()}    = ":"  Sp                   -> {} 
COLONEQ  :: {()}    = ":=" Sp                   -> {} 
COMMA    :: {()}    = ","  Sp                   -> {} 


Sym      :: String  = s:SymChar Sp              -> s 
SymChar  :: String  = "+" / "*" / "-" / "/" 
                    / "&" / "|" / "^" / "%" / "$" / "@" / "!" / "?"
                    / "++" / "--" / "**" / "//" 
                    / "&&" / "||" / "^^" / "%%" / "$$" / "@@" 
                    / "="  / "==" / "!=" / "/=" 
                    / "[" / "]" / "{" / "}" / "(" / ")" 
                    / "<" / ">" / "<=" / ">=" / "<<" / ">>" 
                    / ">>=" / "=<<" / ">>>" / "<<<" 
                    / "." / ".." / "..." / "...." 
                    / "," 


Bool     :: Tm      = "true":Word                   -> { TmTRUE         } 
                    / "false":Word                  -> { TmFALSE        } 


--------- PARSER ------------

TopLevel :: {[Top]} = Sp t:Top Sp ts:TopLevel !Char -> { t:ts           }  
                    / t:Top                         -> { [t]            } 

Top :: Top          = CONTRACT id:ID ps:Params
                        LBRACE ms:Mthds RBRACE      -> { CN id ps ms    }  
                    / EVENT  p:PTy                  -> { EV    p        } 

Params :: {[Ty]}    = LPAREN  ps:PTys  RPAREN       -> { ps             } 
                    / LPAREN           RPAREN       -> { []             }  

PTys    :: {[Ty]}   = p:PTy  COMMA  ps:PTys         -> { p:ps           } 
                    / p:PTy                         -> { [p]            } 

PTy     :: {Ty}     = id:ID  COLON  ty:Ty           -> { TyVAR id ty    }  

Tys    :: {[Ty]}    = t:Ty   COMMA  ts:Tys          -> { t:ts           } 
                    / t:Ty                          -> { [t]            } 

Ty     :: { Ty }    = t:PrimTy Sp                   -> { t              }
                    / a:Ty  ARROW  b:Ty             -> { TyABS a b      } 
                    / LPAREN t:Ty COMMA s:Tys RPAREN-> { TyPROD (t:s)   } 

PrimTy :: { Ty }    = "bool":Word                   -> { TyBOOL         } 
                    /   "u8":Word                   -> { TyU8           } 
                    / "u256":Word                   -> { TyU256         } 
                    /   "i8":Word                   -> { TyI8           } 
                    / "i256":Word                   -> { TyI256         } 
                    / LPAREN t:Ty RPAREN            -> { t              } 



Mthds  :: {[Mthd]}    = m:Mthd ms:Mthds             -> { m:ms           }
                      /                             -> { []             }
Mthd   :: { Mthd }    = METHOD id:ID ps:Params ARROW ret:Ty 
                        LBRACE  k:KTm RBRACE        -> { MT id ret ps k }  

KTm     :: { K Tm } = k:AppKTm                      -> { k              } 

AppKTm  :: { K Tm } = k:PathKTm                     -> { k              } 
                    / k1:AppKTm k2:PathKTm          -> { 
                                                         let (s1,t1) = splitK k1 in 
                                                         let (s2,t2) = splitK k2 in 
                                                         bindK(s1++s2)(TmAPP(K t1)(K t2)) }
PathKTm :: { K Tm } = k:AKTm                        -> { k              } 
AKTm    :: { K Tm } = "(":Sym k:KTm ")"             -> { k              } 
                    / "return":Word k:KTm           -> { k              } 
                    / b:Bool                        -> { pure b         } 


{ 

parse :: String -> [Top] 
parse str = case parserTopLevel (parserParse "" str) of 
    Parsed v _ _ -> v 
    NoParse e -> error (show e) 

}
